#+TITLE: emacs 笔记

#+OPTIONS: ^:nil


* 配置emacs记录
emacs主要用来
- 记笔记
- python 
- C/C++

使用到的插件
- elget：用来自动安装el文件
- color-theme： emacs配色
- dired： emacs的目录
- linum： 行号
- grep：grep-find 查找功能
- borwse-kill-ring：剪切板记录
- ido：C-x C-f的时候，提示
- tramp：用来在emacs中使用root权限打开文件
- org：orgmode 用来记笔记
- cedet 和 ecb：cedet是安装ecb的基础，ecb是据说很好的浏览代码工具，实验中
- cscope： 也是用来浏览代码的。可以实现C/C++代码中函数、变量的跳转
- auto-complete & yasnippet：通用的自动补全工具
- auto-complete-clang：配合auto-complete来实现c/c++的代码补全，函数参数提示等
- jedi：python的代码补全工具
- ipython：python的命令行提示工具



** 使用el-get.el 来安装所有（几乎所有）el文件。

安装elget需要有git。
安装master版本比较好。
https://github.com/dimitri/el-get

** 记笔记就用org-mode了。
emacs自带的org即可，配置文件就是lisps目录中的org-mode-settings.el

** emacs 配置 python
 可以使用jedi来替代之前到rope / ropemacs /ropemode  组合。
*** 使用el-get.el 安装jedi
地址：https://github.com/davidhalter/jedi
在ubuntu中安装好需要到软件之后，直接在M-x el-get-install RET jedi即可安装成功。

在mac中。需要在系统自带的命令行中,jedi的目录中执行 make requestments 。之后在安装。 其他到基本和ubuntu一样。

*** 需要用到ipython.el python-mode.el。

ipython可以通过easy_install 安装。同时需要安装readline。
sudo easy_install ipython readline
    安装时如果遇到“Modules/2.x/readline.c:8:20: 致命错误： Python.h：没有那个文件或目录” 
    需要执行 apt-get install python-dev


python-mode可以在[[https://launchpad.net/python-mode/][官网]] 直接下载使用。


配置文件就看lisps\python\init_python.el init_ipython.el init_initjedi.el

** emacs 中安装auto-complete 和 auto-complete-clang
可以查看 [[http://blog.csdn.net/winterttr/article/details/7524336][ emacs中使用auto-complete的详细设置]]

[[http://blog.csdn.net/winterttr/article/details/7273345][ emacs下使用clang补全C++]]
[[http://blog.csdn.net/cherylnatsu/article/details/7670445][Emacs+auto-complete+clang进行代码补全]]

M-x el-get-install RET auto-complete 
M-x el-get-install RET popup
M-x el-get-install RET fuzzy
M-x el-get-install RET pos-tip
M-x el-get-install RET auto-complete-clang
使用上面命令，可以直接用el-get安装。
- auto-complete:是auto-complete的主要源码
- popup: auto-complete的popup列表
- fuzzy: auto-complete的模糊查找功能
- pos-tip: 用来调整popup函数提示信息的位置。
- auto-complete-clang:配合auto-complete的C/C++自动补全插件。
    需要在机器中安装clang工具。
mac上好像自带clang

ubuntu上使用apt-get install clang 可以安装。


@<font color="#ff0000">echo "" | g++ -v -x c++ -E -   可以得到系统中所有的头文件目录@</font>


配置文件就看init_initjede.el了。

** emacs Mac中安装Cscope
- 在http://cscope.sourceforge.net 中下载最新版本
- 解压
- 修改cscope 源文件
    - vim src/constants.h
    - 在111行后添加
         #undef TERMINFO
         #define TERMINFO
- ./configure && make && make install
** emacs 使用Cscope
生成索引文件才能使用Cscope的强大功能。
1.  首先需要在源码根目录执行
    #+begin_src c
    cscope-indexer -r
    #+end_src
    -r 表示递归检索子目录。会生成2个文件
    - cscope.files：文件列表。即根目录下所有文件名
    - cscope.out：数据库
1.  一般执行上一步之后就足够了，项目中的所有源文件都在文件列表里了。但不能跳转到/usr/include目录。如：想看到printf函数的定义，需要跳转到/usr/include/printf.h文件。
    这时就需要手动把/usr/include下的.h文件都添加到cscope.files文件中。
    使用
    #+begin_src c
      find /usr/include -name "*.h" -o -name "*.c" -o -name "*.cc"  -o -name "*.cpp" -o -name "*.hpp" > cscope.files
    #+end_src
    然后执行下一步
1.  使用cscope -Rb 重新生成cscope.out文件。
    - -R: 在生成索引文件时，搜索子目录树中的代码
    - -b: 只生成索引文件，不进入cscope的界面
    - -k: 在生成索引文件时，不搜索/usr/include目录
    - -q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度
    - -i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用“-”，表示由标准输入获得文件列表。
    - -I dir: 在-I选项指出的目录中查找头文件
    - -u: 扫描所有文件，重新生成交叉索引文件
    - -C: 在搜索时忽略大小写
    - -P path: 在以相对路径表示的文件前加上的path，这样，你不用切换到你数据库文件所在的目录也可以使用它了
    Cscope只在第一次解析时扫描全部文件，以后再调用cscope，它只扫描那些改动过的文件，这大大提高了cscope生成索引的速度。 
    在缺省情况下，cscope在生成数据库后就会进入它自己的查询界面，我们一般不用这个界面，所以使用了“-b”选项。如果你已经进入了这个界面，按CTRL-D退出。

    Cscope在生成数据库中，在你的项目目录中未找到的头文件，会自动到/usr/include目录中查找。如果你想阻止它这样做，使用“-k”选项。

    Cscope缺省只解析C文件(.c和.h)、lex文件(.l)和yacc文件(.y)，虽然它也可以支持C++以及Java，但它在扫描目录时会跳过 C++及Java后缀的文件。如果你希望cscope解析C++或Java文件，需要把这些文件的名字和路径保存在一个名为cscope.files的文 件。当cscope发现在当前目录中存在cscope.files时，就会为cscope.files中列出的所有文件生成索引数据库。
    #+begin_src c
      find /usr/include -name "*.h" -o -name "*.c" -o -name "*.cc"  -o -name "*.cpp" -o -name "*.hpp" > cscope.files
      cscope -bkq -i cscope.files   
     #+end_src

1. Cscope默认在每次进行查找时更新cscope.out。当工程十分庞大时，建议关闭该选项以提高查找速度。方法是在~/.emacs文件中加入
    #+begin_src c  
    (setq cscope-do-not-update-database t)
    #+end_src
1. Cscope可以通过创建反向索引加速查找，方法是调用Cscope时，使用-q参数。真的假的，一试便知。修改cscope-indexer脚本，将
    cscope -b -i $LIST_FILE -f $DATABASE_FILE
    替换为
    cscope -q -b -i $LIST_FILE -f $DATABASE_FILE


@<font color="#ff0000">有的时候会出现建立完索引之后也不能用cscope进行查找，这是可以看看在.c文件的目录中是不是也包含cscope.out这个文件。它会覆盖掉根目录下的cscope.out。导致cscope只在当前目录查找。@</font>

** 记一个题外话，今天突然想起来可以设置clang的include路径。。。。。

* org-Mode
- TAB	 	折叠列表项
- M-RET	 	插入项
- M-S-RET	 	插入带复选框的项
- M-S-UP/DOWN	 	移动列表项
- M-LEFT/RIGHT	 	升/降级列表项，不包括子项
- M-S-LEFT/RIGTH	 	升/降级列表项，包括子项
- C-c C-c	 	改变复选框状态
- C-c -	 	更换列表标记（循环切换


 
| 快捷键         | 命令 | 说明                      |
|                |      |                           |
| TAB            |      | 折叠列表项                |
| M-RET          |      | 插入项                    |
| M-S-RET        |      | 插入带复选框的项          |
| M-S-UP/DOWN    |      | 移动列表项                |
| M-LEFT/RIGHT   |      | 升/降级列表项，不包括子项 |
| M-S-LEFT/RIGTH |      | 升/降级列表项，包括子项   |
| C-c C-c        |      | 改变复选框状态            |
| C-c -          |      | 更换列表标记（循环切换）  |


** 在ubuntu中。执行C-c C-e会提示Can't find library org. 此时安装emacs24-el，并重启emacs即可。


* emacs 启动 daemon模式
** 在windows里面没有daemon，只能M-x server-start 来启动server，之后用emacsclient 文件名来打开新文件。
** linux(ubuntu)
要使用Emacs daemon，至少需要Emacs 23。它提供了一个emacsclient程序，用于启动客户端。

有客户端就必然要有服务端。要启动一个daemon，需要在运行emacs时加入一个–daemon参数。幸运的是，我们不用手动启动服务端，而是可以利用emacsclient的-a参数。emacsclient的-a参数用于指定连接不上服务器时使用的别的编辑器（alternate editor），当把这项留空时，它会自动启动服务端。如果不想指定-a，也可以将ALTERNATE_EDITOR环境变量设为""。除了-a参数，emacsclient还要手工指定使用终端还是X来启动。要从终端启动，需要使用-t参数：
*** 终端启动
emacsclient -t -a ""
*** X启动
emacsclient -c -a ""

** MAC OS
可以通过
*** http://www.emacswiki.org/emacs/EmacsAsDaemon     &    http://kopwei.wordpress.com/2012/12/22/在mac下配置emacs-daemon和client实现瞬间启动


把下面脚本 放到 /Library/LaunchAgents 里面，名为 gnu.emacs.daemon.plist （*.plist）. 可以在mac开机的时候启动emacs daemon，之后就可以直接在命令行调用 emacsclient 来打开文件。

#+BEGIN_SRC script

 <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
        "http://www.apple.com/DTDs/PropertyList-1.0.dtd"> 
     <plist version="1.0">
      <dict> 
        <key>Label</key>
        <string>gnu.emacs.daemon</string>
        <key>ProgramArguments</key>
        <array>
          <string>/Applications/Emacs.app/Contents/MacOS/Emacs</string>
          <string>--daemon</string>
        </array>
       <key>RunAtLoad</key>
       <true/>
       <key>ServiceDescription</key>
       <string>Gnu Emacs Daemon</string>
       <key>UserName</key>
       <string>[YOUR USERNAME HERE]</string>
      </dict>
    </plist>

#+END_SRC


*** https://gist.github.com/redinger/1394910  没试过啦。

1. Open the AppleScript editor and paste the following:

#+BEGIN_SRC c

tell application "Terminal"
do shell script "/Applications/Emacs.app/Contents/MacOS/Emacs --daemon"
end tell

#+END_SRC
Save this as an Application called "Emacs Daemon" in your Applications folder

1. Add as a login item

Goto System Preferences > Accounts

With your user name selected, click on the Login Items tab
Click on the plus sign
Browse to your applications folder and find "Emacs Daemon"
Don't worry about the "hide" checkbox, since it the dock icon disappears naturally
Create the client application
Open the AppleScript editor and paste the following:

#+BEGIN_SRC c

tell application "Terminal"
try
set frameVisible to do shell script "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient -e '(<= 2 (length (visible-frame-list)))'"
if frameVisible is not "t" then
do shell script "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient -c -n"
end if
on error
do shell script "/Applications/Emacs.app/Contents/MacOS/Emacs --daemon"
do shell script "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient -c -n"
end try
end tell
tell application "Emacs" to activate
Save this as an Application called "Emacs Client" in your Applications folder.

#+END_SRC

1. Giving the client application a proper icon

Using the Finder, navigate to your Application folder and right click on your Emacs application (not the client or daemon), and click on Show Package Contents Do the same for the Emacs Client application

Copy the Emacs.icns file from Contents/Resources of the Emacs application to the Contents/Resources of the Emacs Client application Delete applet.icns and rename Emacs.icns to applet.icns in the Emacs Client application.

*** https://github.com/doitian/dotfiles/blob/master/bin/emacs-dwim.mac 用的是这个。虽然我看不懂这个脚本的代码。

#+BEGIN_SRC c

#!/bin/bash
# Author: Ian Yang

# recommend aliases
#
# alias e=emacs-dwim
# alias et='emacs-dwim -t'
# alias en='emacs-dwim -n'

AUTOMATOR=
# AUTOMATOR=1
#   set AUTOMATOR to 1 when used in automator as Application:
#
#   1.  Create an Application in Automator
#   2.  Add an action to run Shell
#   3.  Select "pass input as arguments".
#   4.  Paste this file into the text area, and set AUTOMATOR=1
#
#   -   You can use the Application in "Open With..." or used as default handler.
#   -   You can drag a file into this Application, and the file is opened in Emacs.
#   -   You can add this Application in "System Preference -> Accounts -> Login Items" to auto
#       start Emacs daemon.
#
EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs
EMACSCLIENT=/Applications/Emacs.app/Contents/MacOS/bin/emacsclient

export LC_CTYPE=zh_CN.UTF-8
export LC_ALL=

_is_emacs_daemon_started () {
  netstat -nl 2> /dev/null | awk '{print $NF}' | grep -q "emacs$UID/server"
}
_is_emacs_window_exist () {
  _is_emacs_daemon_started && \
    $EMACSCLIENT -e '(<= 2 (length (visible-frame-list)))' | grep -q -x t
}

kill_emacs () {
  if _is_emacs_daemon_started; then
    $EMACSCLIENT -e -n '(let ((desktop-save '\''if-exists)) (dolist (f (cdr-safe (reverse (frame-list)))) (delete-frame f t)) (kill-emacs "yyyyyy"))'
    if _is_emacs_daemon_started; then
      ps -u $UID -o pid,comm= | grep Emacs$ | cut -d' ' -f1 | xargs -n 1 kill
    fi
  fi
  return 0
}

main () {
  if ! _is_emacs_daemon_started; then
    if $EMACS --daemon &> /tmp/emacs$UID.log; then
      echo ' [sucess]'
    else
      echo ' [faild]'
      return 1
    fi
  fi

  local cur=$(osascript -e 'path to frontmost application as Unicode text')
  if [ "$1" = "-t" ]; then
    $EMACSCLIENT "$@"
  elif [ -z "$1" ]; then
    if ! _is_emacs_window_exist; then
      $EMACSCLIENT -n -c
    fi
    osascript -e 'tell application "Emacs" to activate'
    return 0
  else
    if ! _is_emacs_window_exist; then
      $EMACSCLIENT -n -c
    fi
    if ! echo "$*" | grep -q -e '-n'; then
      osascript -e 'tell application "Emacs" to activate'
    fi
    $EMACSCLIENT "$@"
  fi
  osascript -e "tell application \"${cur}\" to activate"
}

if [ -n "$AUTOMATOR" ]; then
  [ -n "$1" ] \
    && main -n "$@" \
    || main
else
  [ -n "$1" -a "$1" = "-q" ] \
    && kill_emacs \
    || main "$@"
fi

#+END_SRC

* emacs 关闭daemon模式
1. 在emacs外部,可以使用 emacsclient -e '(kill-emacs)' 来关闭emacs daemon
1. 在emacs内部,可以使用 kill-emacs 或者 save-buffers-kill-emacs 命令。

* emacs root权限打开文件
1. Installing and configuring
    在emacs里面添加：（emacs22版本里面已经默认添加了tramp模块）
  
  ;;tramp

     (setq tramp-default-method "scp")

     (setq tramp-auto-save-directory "~/emacs/tramp")

     (setq auto-save-file-name-transforms

    '(("\\`/[^/]*:\\(.+/\\)*\\(.*\\)" "/tmp/\\2")))

    (setq tramp-chunksize 328)

    (require 'ange-ftp)

    (require 'tramp)

2. How to use
    编辑root权限的文件：C-x C-f /su:root@localhost:/ 然后输入root密码，或者C-x C-f /sudo: 输入用户的密码

    使用ftp，ssh等可以编辑远程文件，具体可以参考：

    http://blog.donews.com/pluskid/archive/2006/05/06/858306.aspx

3. Tramp和ido的冲突
    很不幸，这个和ido.el有些冲突，找了比较久也没找到一个解决方法，只好在想使用tramp的时候使用M-x ido-mode暂时关闭ido-mode。打开需要编辑的文件后就可以继续使用ido-mode了。

* emacs 设置C语言编辑
设置c-set-style可以制定类似tab/4空格 缩进，大括号缩进之类的东西。

[[http://www.emacswiki.org/emacs/IndentingC][C语言缩进网站]]
#+begin_src c
(setq-default c-indent-tabs-mode t     ; Pressing TAB should cause indentation
                c-indent-level 4         ; A TAB is equivilent to four spaces
                c-argdecl-indent 0       ; Do not indent argument decl's extra
                c-tab-always-indent t
                backward-delete-function nil) ; DO NOT expand tabs when deleting
  (c-add-style "my-c-style" '((c-continued-statement-offset 4))) ; If a statement continues on the next line, indent the continuation by 4
  (defun my-c-mode-hook ()
    (c-set-style "my-c-style")
    (c-set-offset 'substatement-open '0) ; brackets should be at same indentation level as the statements they open
    (c-set-offset 'inline-open '+)
    (c-set-offset 'block-open '+)
    (c-set-offset 'brace-list-open '+)   ; all "opens" should be indented by the c-indent-level
    (c-set-offset 'case-label '+))       ; indent case labels by c-indent-level, too
  (add-hook 'c-mode-hook 'my-c-mode-hook)
  (add-hook 'c++-mode-hook 'my-c-mode-hook)

#+end_src
* Emacs 一些默认快捷键
** 字母大小写转换 
#+begin_src c
capitalize-word (M-c) ;; 单词首字母转为大写
upcase-word (M-u)     ;; 整个单词转为大写
downcase-word (M-l)   ;; 整个单词转为小写（注意，这里是 META － l(* 小写字母 L)）
#+end_src


** buffer 列表
按 'd' 键，比较buffer删除。之后按 'x' 键，执行删除。可以关闭一个buffer。
* emacs 字体
inconsolata 确实是很帅的字体。

使用 sudo apt-get install ttf-inconsolata
安装 inconsolata字体

在.emacs文件中 (set-default-font "Inconsolata-12") 设置emacs的默认字体。
* emacs 使用
** 括号跳转
在emacs中，当光标在某个括号 "{ ( [" 任何一个括号的时候， 可以使用按键 C-M-n   C-M-p来跳转到对应的括号
C-M-n : 跳转到对应的括号， 向前
C-M-p : 跳转到对应的括号， 向后
** 函数跳转
C-M-a : 光标定位到当前函数头
C-M-e : 光标定位到当前函数尾
** 设置Mark
设置mark是为了从设置mark的地方选中某些行。
set-mark-command     对应快捷键   C-@
** 代码折叠
这里说的是emacs自带的HideShow mode.
进入HideShow mode： M-x hs-minor-mode（幸亏有tab键。。要不这么长的命令=。=）
主要的功能：
-  C-c @ C-M-s 显示所有的代码
-  C-c @ C-M-h 折叠所有的代码
-  C-c @ C-s 显示当前代码区
-  C-c @ C-h 折叠当前代码区
-  C-c @ C-c 折叠/显示当前代码区
** 批量替换字符串
1. find-dired 来指定一个希望替换的目录。
1. find-dired 之后，可以指定参数来确定需要替换的文件类型。 类似 -name "*.cpp"
1. 之后，emacs会根据上两步的命令来生成一个文件列表。
1. 可以在这个列表里，用‘m’来标记需要进行字符串替换的文件。
1. 用 M-x dired-do-query-replace-regexp 命令来进行替换。

* 单行注释
M-; 可以自动在行的后面添加注释标志。  
lisp里面是 ;;   C/C++ 里面是 /**/

* 移动到当前行第一个非空字符
M-m 
* emacs 正则表达式
正则表达式(regular expressions, 缩写为regexp)是由几个特殊字符和一些普通 字符组成，一个普通字符就是一个简单的正则表达式，仅仅可以匹配与自己相同的字符。而特殊字符包括“$”，“^”，“.”，“*”，“+”，“?”，“[”，“]”以  及“\”。除非在一个字符前面有“\”，否则正则表达式中出现的任何其他字符都是普通字符，（当你在 Lisp 程序中使用正则表达式时，每一个“\”都必须写成两个，  因为需要对字符串中的“\”转义，请看下面的例子。

      例如，“f”不是特殊字符，是普通字符，因此“f”是一个正则表达式，它仅仅  匹配串“f”。（不匹配“ff”。）同样“o”是仅匹配串“o”的正则表达式。（当不区分大小写时，前面的两个式子也匹配“F”和“O”，而实际上，一般认为它们是  “同样的串”，并不是因为例外。）     两个任意的表达式 A 和 B 可以连接，其结果是能够匹配以 A 开始，其余部分是  B 的字符串的表达式。

      举个简单的例子，我们将表达式“f”和“o”连接，得到表达式“fo”，仅匹配 串“fo”，很简单的。想做些不简单的，需要使用特殊字符。下面介绍这些特殊字符。
** 特殊字符
*** “. (Period)”
      匹配除了换行符(newline)之外任何单个字符的特殊字符。通过“连接”，可以得 到如“a.b”的表达式，匹配所有的以“a”开始，以“b”结束的三个字符的字符
     串。
*** “*”
      自身不构成表达式的部分，作为后缀操作符，表示某个前导表达式可以任意次重复。比如，“o*”匹配任意个“o”连成的串（包括空串）。“*”总是作用于“最少的”可能的前导表达式。于是，“fo*”中，可以重复的 是“o”，而不是“fo”，匹配形如“f”, “fo”, “foo”的串等等。
      匹配程序以迅速且尽可能多的找到重复部分来处理带“*”的结构。然后继续其他部分的处理。如果失败了，为了使剩余的部分能够尽可能的匹配，匹配程序会回 退，释放一些已经由“*”匹配的结构。
        例如，在使用“ca*ar”来匹配串“caaar”时，“a*”首先试图匹配全部的三个“a”；但余下的部分是“ar”，不能匹配“r”，失败；接着选择是用“a*”匹配两个“a”，成功。
*** “+”
      和“*”相似的后缀操作符，它表示前导表达式至少出现一次。例如，“ca+r”匹  配串“car”和“caaaar”，但不能匹配“cr”，然而“ca*r”却可以。
*** “?”
      也是一个和“*”相似的操作符，它表示前导表达式至多出现一次。例如，“ca?r”仅仅匹配“car”或“cr”。
*** “*?, +?, ??”
      是前面几个操作符的非贪心(non-greedy)的变体。正常的“*”， “+”， “?” 操作符是“贪心的(greedy)”，只要总体上能够匹配，这些操作符总是尽可能多  的匹配。当紧跟着“?”时，则是非贪心的：将尽可能少的匹配。
      “ab*”和“ab*?”都能匹配串“a”和“abbbb”；但如果你试图用它们来匹配“abbbb”时，“ab*”将匹配全部（最长有效匹配），而“ab*?”将仅仅匹配
      “a”（最短有效匹配）。
*** “\{N\}”
      指定重复次数为 N 的后缀操作符，前导表达式必须恰好出现 N 次。例如“x\{4\}”仅匹配串“xxxx”。
*** “\{N,M\}”
      指定重复次数在N和M之间的后缀操作符，就是说它的前导表达式的出现次数至少 是N 但不能超过 M。如果省略 M，表示没有上限，但它的前导表达式至少出现 N 次。“\{0,1\}”等于“?”。“\{0,\}”等于“*”。“\{1,\}”等于“+”。
*** “[ ... ]”
      字符集，以“[”开始以“]”结束。最简单的例子，在两个方括号中间的字符就 是这个集合所能匹配的全部。 所以，“[ad]”仅匹配一个“a”或一个“d”，“[ad]*”匹配所有仅由“a”和“d”构成的串（和空串）。“c[ad]*r”匹配“cr”，“car”， “cdr”，“caddaar”，等等。
      也可以用一个“-”放在一个开始字符和一个结束字符的中间，表示字符集中字符 的范围。“[a-z]”匹配所有小写 ASCII 字母。范围可以和单独的字符自由的组  合在一起，比如“[a-z$%.]”，匹配了任意的小写字母，或“$”，“%”，以及“.”。
      注意，通常在字符集中的特殊字符不再特殊，而在字符集中的“]”，“-”和   “^”却是特殊字符。
      如果想在字符集中包括字符“]”，必须放在第一个字符位置。例如，“[]a]”匹 配“]”或“a”。想包括“-”，要在第一个或最后一个位置，或在一个范围的后  面，如“[]-]”匹配“]”和“-”。
      如果想在字符集中包括字符“^”，不可以放在第一个位置。（在开始位置，它会 把这个字符集取补——看下面。）
      当不区分大小写使用范围时，表示范围的两个字符或者都是大写、或者都是小写、 或者都不是字母。混合大小写的范围如“A-z”意思不明确，不被接受，或许在将 来的 Emacs 中会被改变。
*** “[^ ... ]”
      “[^”表示“补集合”，匹配的字符是除掉指定的字符外其他所有的字符。如，“[^a-z0-9A-Z]”匹配除掉ASCII字母和数字的所有字符。
      当“^”在字符集中第一个时，被看作是特殊字符。而跟在“^”后面的字符被看作是第一个字符（就是说，此处的“-”和“]”将不是特殊的）。
      一个补集合可以匹配换行符，除非换行符被指定为补集合中的一个字符。这不同于某些象“grep”的程序对正则表达式的处理。
*** “^”
      仅仅匹配在文本中行首的那个空串的特殊字符。就是说，“^foo”匹配在行首的”foo”。
        (匹配空串：比如"^fo" 就是说fo必须在一行的第一个字符,前面不能有空格等什么的，又如"fo$"就是fo必须是一行的最后一个字符，后面不能再有其他的任何字符----个人理解)
*** “$”
      和“^”相似，但仅匹配行尾的空串。因此“x+$”匹配在行尾的一个或多个“x”  的串。
*** “\”
      有两个作用：引用特殊字符（包括“\”）；产生附加的特殊结构。
      
      因为“\”引用特殊字符，“\$”是一个仅匹配“$”的表达式，“\[”是一个仅   匹配“[”的表达式，等等。
** 关于反斜线
      注意：为考虑兼容性，如果在其没有意义的上下文中，特殊字符将被当作普通字符。比如：“*foo”中把“*”当作普通字符，因为在它前面没有可以作用的前导表达 式。很少有人会根据这条规则去实践；无论如何，在任何地方都加上引用会更好些。
      对于大多数情况，“\”后接任何字符仅仅匹配那个字符。然而，有几个例外： 以“\”开始的两字符序列会有特殊的意思。其中的第二个字符往往是普通字符。
“\”的结构表
(注意所有实际应用时候，都要加两个\\，下面是简写如 第一个"\|" 在实际中要写成“\\|" 第一个\表示引出第二个\ ，第二个\引出后面的字符(本例是|)是特殊字符)
*** “\|” 
      指定一个选择。中间有一个“\|”的两个正则表达式 A 和 B，形成了一个可以匹  配 A 或 B 的文本。它首先试图用 A 匹配，如果失败再用 B 去试。
      由此，“foo\|bar”仅匹配“foo”或“bar”。“\|”作用于两边最长的可能的表达式。仅由“\( ... \)”括起来才可以限制“\|”的分组能力。
      Emacs 有全面的回退功能，以处理“\|”的多种的用途。
*** “\( ... \)”
      分组结构，有三个功能：
1.围住“\|”的选择项，以实现别的操作。例如“\(foo\|bar\)x”匹配“foox”或“barx”。
2.围住复杂的表达式以实现后缀操作符（如“*”“+”和“?”）的操作。例如 “ba\(na\)*”匹配如“bananana”等，有任意个（零或更多）的“na”串。
3.记录一个已匹配的子串用作后面的参考引用。
      最后一个应用并不是括号的分组功能思想的结果；这个分开的特点是给同样的“\( ... \)”结构赋予的第二种含义。在实际应用中，这两种含义通常不会发生 冲突。当发生冲突的时候，可以使用“谨慎的”分组("shy" group)。
*** “\(?: ... \)”
      “谨慎的”分组("shy" group)，这个分组不记录匹配的子串；你不能用“\D”来 引用。这在机械的结合正则表达式的时候有用，这样，你可以为语法目的加入分   组，而不用干涉使用者写的分组的个数。
*** “\D” 
      匹配和“\( ... \)”结构第 D 次出现时所匹配的同样的文本。
            如："(abc)(def)(ghi)\\2"  \\2引用的是(def)
      在“\( ... \)”结构结束之后，匹配程序保存被这个结构匹配的文本（的开始和  结束）；之后的正则表达式中，你可以使用“\”跟着一个数字 D 来表示“匹配   和‘\( ... \)’结构第 D 次出现时所匹配的同样的文本。”
      正则表达式中前九个出现的“\( ... \)”结构，按正则表达式中左括号出现的次 序从 1 到 9 赋值。因此可以用“\1”到“\9”来引用相应的“\( ... \)”结构。
      例如，“\(.*\)\1”匹配任何有完全相同的两部分而无换行符的串。“\(.*\)” 匹配前一半，可以是任意的串，“\1”匹配后面的，但必须和前面的完全相同。
      如果一个特定的“\( ... \)”结构匹配了多次（比如后面有一个“*”，这很显  然），那么仅记录最后一次的匹配。
*** “\`” 
      匹配空串，但仅是接在缓冲区的开始处的。
*** “\'” 
      匹配空串，但仅是接在缓冲区的尾部的。
*** “\=” 
      匹配空串，但仅在“点(point)”处的。
*** “\b” 
      匹配空串，但仅在一个词的开始或者结尾的。例如，“\bfoo\b”匹配任何作为单 独的词出现的“foo”。“\bballs?\b”匹配作为单独的词出现的“ball”或"balls”。
      在缓冲区的开始和结束位置时，“\b”不考虑紧接其前的文本是什么。
*** “\B” 
      匹配空串，但不在词的开始或结尾处。
*** “\<” 
      匹配空串，但仅在词的开始处。仅当一个构成词的字符在缓冲区开始处时“\<” 匹配缓冲区开始处的空串。
*** “\>” 
      匹配空串，但仅在词的结尾处。仅当缓冲区尾部有构成词的字符时“\>”匹配缓 冲区尾部的空串。
*** “\w” 
      匹配任何构成词的字符。由语法表决定这些字符是什么。
*** “\W” 
      匹配任何非构成词的字符。
*** “\sC”
      匹配任何语法是 C 的字符。这里 C 是一个指定特定语法类的字符：如“w”为词 的构成字符，“-”或“ ”为空白，“.”为普通标点符号，等等。
*** “\SC”
      匹配任何字符不属于语法 C。
*** “\cC”
      匹配任何属于种类 C 的字符。例如，“\cc”匹配汉字，“\cg”匹配希腊字符等。 如果想了解已知种类，用“M-x describe-categories ”。
*** “\CC”
      匹配所有不属于种类C的字符。  属于词和语法的结构是由语法表的设置来控制的。
** 例子

        下面是一个复杂的正则表达式，存储在“sentence-end”，Emacs 将其用于识 别句子的结束以及后面的任何空白。其中以 Lisp 语法区分了空白符和制表符。在  Lisp 语法中，串常量用双引号括起来。“\"”表示双引号是表达式的一部分，“\\”表示反斜扛是表达式的一部分，“\t”表示制表符，“\n”表示换行。
         "[.?!][]\”‘)]*\\($\\| $\\|\t\\|  \\)[ \t\n]*”
    其中包含四个连续的部分：匹配句号(“.”)、“?”或“!”的字符集；匹配右方括号、右(单/双)引号的字符集的任意次重复的部分；在“反斜线括号”部分中，匹配行尾、行尾空白、制表符或两个空格的可选集合；以及一个任意次匹配空白的字符集。增量搜索中，要用 TAB 输入制表符，“C-j”输入换行符。也可以使用单 独的反斜线，不用象 Lisp 串中那样写成两个。

* emacs 设置
** 密码显示成***号
#+BEGIN_SRC lisp
(add-hook 'comint-output-filter-functions
          'comint-watch-for-password-prompt)

#+END_SRC
** emacs中强制使用空格代替TAB
    在emacs中可以强制使用空格代替TAB，网上也有许多资料了，我这里说到的是有时在.emacs文件中加入了(setq indent-tabs-mode nil)之后也不管用，编辑时依然会插入TAB。
    我在配置cc-mode时就出现了这样的问题，配置文件中加入了(setq indent-tabs-mode nil)，但依然插入TAB。
    这时其实应该查看下这个变量的值，是不是真的已经设置为了nil。用C-h v再输入indent-tabs-mode查看之后，应该这个值还是t。即它并没有被设置为nil。
    如果你使用了cc-mode的配置，会发现在cc-mode的style定义中加入(setq indent-tabs-mode nil)是无效的，而在其hook定义中加入就是有效的：
(defconst mystyle
   '((setq indent-tabs-mode nil))
    "mystyle" )
(c-add-style "mystyle" mystyle)
(defun myhook()
(c-set-style "mystyle"))
(add-hook 'c++-mode-hook 'myhook)
    这样设置后，打开一个新文件，查看indent-tabs-mode的值，还是t。如下的设置才是正确的设置：
(defconst mystyle
   '(......)
    "mystyle" )
(c-add-style "mystyle" mystyle)
(defun myhook()
   (setq indent-tabs-mode nil)
(c-set-style "mystyle"))
(add-hook 'c++-mode-hook 'myhook)
