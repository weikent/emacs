#+TITLE  XCODE

* 关于xib
  用xib文件添加视图的时候，在4.2版本的xcode中，程序会报错。需要把view按住control键拖到文件里面。生成一下自动代码，并删除自动代码之后就正常了。
** Xcode4.2 
   Xcode4.2 中清理xib缓存
   1. option + product menu    ->  Clean Build Folder
   2. iOS Simulator -> Reset Content and settings

* Xcode 调试
在project-setting中找到 “Run Static Analyzer” 键，然后把值修改为“YES”.这样在编码的时候，xcode就可以自动为我们检查内存泄露了
* ios 10.8 xcode 4.5 添加的view 默认是iphone样式。
可以在选中view之后，选择attributes inspector --> size。 可以改变样式。

* ios6 之后添加了 auto layout 功能。 需要关闭的时候可以如下操作
使用Xcode 4.5 创建App时，Auto Layout功能在所有nib或Storyboard 文件中，默认是enable（开启的）
需要关闭storyboard或xib界面文件的Use Auto Layout 选项，这是因为Auto Layout特性是iOS 6 新增加的，在之前的 5.0/5.1 Simulator模拟器中不支持。
1 open user interface document
2 choose view --> Utilities --> show file inspector --> interface Builder Document 下。 uncheck “use auto layout".

* 编程技巧
** 点击界面空白出隐藏keyboard。 也可以做其他事情。
#+begin_src objc
-(void) touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    [super touchesBegan:touches withEvent:event];
    
    [name resignFirstResponder];
    [password resignFirstResponder];
    
}
#+end_src

** TextField 输入完毕后 隐藏 keyboard
实现textField 的 didEndonExit 事件。在方法里面写上 

#+begin_src objc
[textfiel resignFirstResponder];
#+end_src


** 使控件不可用
设置控件的 userinterfaceEnabled

#+begin_src objc
[control setUserInteractionEnabled:YES];
#+end_src


** xcode 调试 EXC_BAD_ACCESS  
1. 第一种方法：在程序 crash 之后，在控制台输入 bt，就可以显示 crash 堆栈：

2. 为工程运行时加入 NSZombieEnabled、 MallocStackLogging环境变量，并设为启用。 produce-->edit schema-->run (environment variables)中

3. MallocStackLogging 启用

4. 为工程运行时加入 NSZombieEnabled 环境变量，并设为启用。


* 获取IOS设备的类型和系统版本
#+begin_src objc
//  DeviceHelper.m   
//  DeviceUtil   
//   
//  Created by LUOYL on 12-4-9.   
//  Copyright (c) 2012年 http://luoyl.info. All rights reserved.   
//   
  
#import "DeviceHelper.h"   
#import "sys/utsname.h"   
  
@implementation DeviceHelper   
  
/*  
 *功能：获取设备类型  
 *  
 *  AppleTV2,1    AppleTV(2G)  
 *  i386          simulator  
 *  
 *  iPod1,1       iPodTouch(1G)  
 *  iPod2,1       iPodTouch(2G)  
 *  iPod3,1       iPodTouch(3G)  
 *  iPod4,1       iPodTouch(4G)  
 *  
 *  iPhone1,1     iPhone  
 *  iPhone1,2     iPhone 3G  
 *  iPhone2,1     iPhone 3GS  
 *  
 *  iPhone3,1     iPhone 4  
 *  iPhone3,3     iPhone4 CDMA版(iPhone4(vz))  
 
 *  iPhone4,1     iPhone 4S  
 *  
 *  iPad1,1       iPad  
 *  iPad2,1       iPad2 Wifi版  
 *  iPad2,2       iPad2 GSM3G版  
 *  iPad2,3       iPad2 CDMA3G版  
 *  @return null  
 */  
+ (NSString *)getDeviceVersion   
{   
    struct utsname systemInfo;   
    uname(&systemInfo);   
    //get the device model and the system version   
    NSString *machine =[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];    
    return machine;   
}   
  
/** 获取IOS系统的版本号 */  
+ (NSString*)getOSVersion   
{   
    return [[UIDevice currentDevice]systemVersion];   
}   
  
/** 判断当前设备是否ipad */  
+ (BOOL)isIpad   
{   
    return [UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPad;   
}   
  
/** 判断当前设备是否iphone */  
  
+ (BOOL)isIphone   
{   
    return [UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPhone;   
  
}   
  
/** 判断当前系统是否有摄像头 */  
+ (BOOL)hasCamera   
{   
    return [UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera];   
}   
  
@end   

#+end_src 

* iOS学习笔记――字符串编码转换

我们知道，使用NSURLConnection的代理方法下载网页，存到一个NSData中，

#+begin_src objc
NSMutableData *pageData;
[pageData appendData:data];
#+end_src

如果网页编码是UTF-8的，可以这么转换为字符串：

#+begin_src objc
NSString *pageSource = [[NSString alloc] initWithData:pageData encoding:NSUTF8StringEncoding];
#+end_src 

如果网页是gbk（或者gb2312），用UTF8转换的话，pageSource返回nil。这时需要使用gbk编码做转换，但是NSStringEncoding不含gbk，怎么办？用另一个方法处理一下：

#+begin_src objc
NSStringEncoding gbkEncoding = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);
NSString *pageSource = [[NSString alloc] initWithData:pageData encoding:gbkEncoding];
#+end_src

为什么可以这么处理？在NSString.h（按住command，双击NSStringEncoding即能查看），对NSStringEncoding的定义中，注释这么写着：

Note that in addition to the values explicitly listed below, NSStringEncoding supports encodings provided by CFString.

See CFStringEncodingExt.h for a list of these encodings.

See CFString.h for functions which convert between NSStringEncoding and CFStringEncoding.


* 造成unrecognized selector sent to instance……程序崩溃原因分析  

造成unrecognized selector sent to instance……，大部分情况下是因为对象被提前release了，在你心里不希望他release的情况下，指针还在，对象已经不在了。
很多时候，是因为init初始化函数中，对属性赋值没有使用self.foo赋值，而是直接对foo赋值，导致属性对象没有retain(心里以为retain了)，而提前释放。

属性必须用 self 
属性必须用 self 属性必须用 self 属性必须用 self 属性必须用 self 属性必须用 self 属性必须用 self 属性必须用 self 属性必须用 self 属性必须用 self 
=======

* 如何将NSstring转欢成char (UTF8String, cString)
如果是 .m文件，直接可以转换

#+begin_src objc
char *s;
NSString *str;
s=[str UTF8String];

str=[NSString stringWithUTF8String:s];
str=[NSString stringWithFormat:@"%s",s];
#+end_src

如果是.mm会提示出错,因为[str UTF8String]返回的是const char *


* Cocoa Fundation内存释放原则

1. 通过分配或复制创建的对象保持计数1
2. 假设任何别的方法获取的对象保持计数1,而且在自动释放池中. 要想在当前执行范围外使用该对象,就必须保持它
3. 向集合添加对象时它就被保持,从集合移除对象时就被释放.释放集合对象会释放该集合中的所有对象
4. 确保有多少alloc,copy,mutableCopy或retain消息就有多少release或autorelease消息发送给该对象. 换句话说,确保你的代码平衡
5. 在访问方法设置属性,先保持,再释放 (ztime: 现在有@propperty , @synthesize 两个指令自动创建此代码)
6. 用@"..."结构创建的NSString对象是常量.发送release或retain并无效果

* 删除视图中的子视图

#+begin_src objc
  for (UIView *oneView in cell.subviews ) {
      if ([oneView isKindOfClass:[UILabel class]]) {
          [oneView removeFromSuperview];
      }
  }
#+end_src
=======
* iPhone 程式要g隔一段rg绦心函式的方法
最基本的就是用NSTimer ..
只是@要建一 NSTimer 再做一些O定..
感X有c麻..

有看到另一N方法.
[self performSelector:@selector(test:) withObject:nnil afterDelay:1.0];



可以O定^酌脶绦.
要一直绦芯驮诤式中也加上同用令.就一直M去了.
要停止的就做判,l件_到的r候不跑命令就好.

另外在cocos2De也有



[self schedule:@selector(objMove:) interval:0.01f];
的方式可以_成.
不^@跟 performSelector:(selector)... 方法有c不一.
就是 schedule 比^像timer 一直绦.. (其e面好像就是湍闾理timer的宣告..)
所以要停止的要用
[self unschedule:@selector(objMove:)];

硗Ｖ惯@幼鞯睦^m绦.
=======
* 设置UIPickerView默认选择

#+begin_src objc
[[self pickerView] selectRow:3 inComponent:0 animated:NO];
#+end_src objc

* UIView层次管理 放到最上层 放到最下层

将一个UIView显示在最前面只需要调用其父视图的 bringSubviewToFront（）方法。
将一个UIView层推送到背后只需要调用其父视图的 sendSubviewToBack（）方法。

* iOS Programming C 触摸事件处理
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;

当手指接触屏幕时，就会调用touchesBegan:withEvent方法；
当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；
当手指离开屏幕时，就会调用touchesEnded:withEvent方法；
当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。而这几个方法被调用时，正好对应了UITouch类中phase属性的4个枚举值。

[self.nextResponder touchesBegan:touches withEvent:event];
可以把事件传递到下一个相应事件的view。

* 遇到的问题
** uinavigationController  pushviewController 的时候是不是需要把 push的viewcontroller给release掉。
 答案是需要。因为push会retain。
 但当时的情况是 release 这个push 的viewcontroller会导致exec_bad_access错误。

 原因是在这个被push的viewcontroller中，有些不需要release的view或button、label之类的控件被release掉了。
 并且没有实现dealloc 方法。

 autorelease的不需要手动release。

 dealloc方法中要写上 [super dealloc]。会自动释放标记为autorelease的控件。
** incomplete implementation
这个一般来说是在.h文件中声明了。却没有在.m文件中实现方法。
